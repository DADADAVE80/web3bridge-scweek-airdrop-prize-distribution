// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Import Chainlink VRF contract
import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
// import ERC20
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract PrizeDistribution is VRFConsumerBaseV2, ERC20 {
    // State variables
    address public owner; // The owner of the contract
    uint256 public prizePool; // The amount of tokens in the prize pool
    uint256 public entryLimit; // The maximum number of entries per participant
    uint256 public prizeDistributionPeriod; // The duration of the prize distribution in seconds
    uint256 public prizeDistributionStartTime; // The start time of the prize distribution
    uint256 public prizeDistributionEndTime; // The end time of the prize distribution
    uint256 public numberOfWinners; // The number of winners to be selected
    mapping(address => uint256) public entries; // The number of entries for each participant
    mapping(uint256 => address) public participants; // The participants indexed by their entry number
    uint256 public participantCount; // The total number of participants
    address[] public winners; // The array of winners
    mapping(address => uint256) public rewards; // The rewards for each winner

    // Chainlink VRF variables
    uint256[] public randomResult; // The random number generated by Chainlink VRF
    uint64 subscriptionId; // VRF subscription ID
    bytes32 public keyHash =
        0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f; // The key hash for Chainlink VRF
    VRFCoordinatorV2Interface immutable COORDINATOR; // The Chainlink VRF coordinator
    uint32 callbackGasLimit = 100000; // The gas limit for the VRF callback
    uint16 requestConfirmations = 3; // The number of confirmations required for the VRF request (can only be higher)
    uint32 numWords = 2; //
    struct RequestStatus {
        bool fulfilled; // whether the request has been successfully fulfilled
        bool exists; // whether a requestId exists
        uint256[] randomWords;
    }
    mapping(uint256 => RequestStatus) public requests; // requestId --> requestStatus
    // past requests Id.
    uint256[] public requestIds;
    uint256 public lastRequestId;

    /**
     * HARDCODED FOR MUMBAI
     * COORDINATOR: 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed
     */
    // Constructor
    constructor(
        uint64 _subscriptionId
    )
        VRFConsumerBaseV2(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed) // Initialize the VRFConsumerBase contract
        ERC20("Web3Bridge Cohort X", "W3CX") // Initialize the ERC20 contract
    {
        owner = msg.sender; // Set the owner of the contract
        subscriptionId = _subscriptionId; // Set the subscription ID
        COORDINATOR = VRFCoordinatorV2Interface(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed);
    }

    // Modifier to check if the caller is the owner
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function");
        _;
    }

    // Modifier to check if the prize distribution is active
    modifier prizeDistributionActive() {
        require(
            block.timestamp >= prizeDistributionStartTime &&
                block.timestamp <= prizeDistributionEndTime,
            "The prize distribution is not active"
        );
        _;
    }

    // Modifier to check if the prize distribution is not active
    modifier prizeDistributionNotActive() {
        require(
            block.timestamp < prizeDistributionStartTime ||
                block.timestamp > prizeDistributionEndTime,
            "The prize distribution is active"
        );
        _;
    }

    // Function to update the prize pool
    function updatePrizePool(
        uint256 _prizePool
    ) external onlyOwner prizeDistributionNotActive {
        prizePool = _prizePool; // Set the prize pool
    }

    // Function to update the prize distribution period
    function updatePrizeDistributionPeriod(
        uint256 _prizeDistributionPeriod
    ) external onlyOwner prizeDistributionNotActive {
        prizeDistributionPeriod = _prizeDistributionPeriod; // Set the prize distribution period
    }

    // Function to start the prize distribution
    function startPrizeDistribution()
        external
        onlyOwner
        prizeDistributionNotActive
    {
        require(prizePool > 0, "The prize pool is empty"); // Check if the prize pool is positive
        prizeDistributionStartTime = block.timestamp; // Set the start time of the prize distribution
        prizeDistributionEndTime =
            prizeDistributionStartTime +
            prizeDistributionPeriod; // Set the end time of the prize distribution
    }

    // Function to end the prize distribution
    function endPrizeDistribution() external onlyOwner prizeDistributionActive {
        prizeDistributionEndTime = block.timestamp; // Set the end time of the prize distribution
    }

    // Function to register as a participant
    function register(uint256 _entries) external prizeDistributionActive {
        require(_entries > 0, "The number of entries must be positive"); // Check if the number of entries is positive
        require(
            entries[msg.sender] + _entries <= entryLimit,
            "The number of entries exceeds the limit"
        ); // Check if the number of entries is within the limit
        entries[msg.sender] += _entries; // Increase the number of entries for the sender
        for (uint256 i = 0; i < _entries; i++) {
            // Loop through the number of entries
            participantCount++; // Increase the participant count
            participants[participantCount] = msg.sender; // Add the sender to the participants
        }
    }

    // Function to request randomness from Chainlink VRF
    function requestRandomWords()
        external
        onlyOwner
        prizeDistributionNotActive
        returns (uint256 requestId)
    {
        requestId = COORDINATOR.requestRandomWords(
            keyHash,
            subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
        requests[requestId] = RequestStatus({
            randomWords: new uint256[](0),
            exists: true,
            fulfilled: false
        });
        requestIds.push(requestId);
        lastRequestId = requestId;
        return requestId;
        // bytes32 requestId = requestRandomness(keyHash); // Request randomness from Chainlink VRF
    }

    // Function to receive randomness from Chainlink VRF
    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {
        require(requests[_requestId].exists, "request not found");
        requests[_requestId].fulfilled = true;
        requests[_requestId].randomWords = _randomWords;
        // selectWinners(); // Call the function to select winners
    }

    function getRequestStatus(
        uint256 _requestId
    ) external view returns (bool fulfilled, uint256[] memory randomWords) {
        require(requests[_requestId].exists, "request not found");
        RequestStatus memory request = requests[_requestId];
        return (request.fulfilled, request.randomWords);
    }

    // Function to select winners
    function selectWinners() internal {
        require(randomResult.length > 0, "Randomness not generated yet"); // Check if the randomness is generated
        require(winners.length == 0, "Winners already selected"); // Check if the winners are already selected
        require(
            numberOfWinners > 0 && numberOfWinners <= participantCount,
            "Invalid number of winners"
        ); // Check if the number of winners is valid
        for (uint256 i = 0; i < numberOfWinners; i++) {
            // Loop through the number of winners
            uint256 index = ((randomResult[i] + i) % participantCount) + 1; // Calculate the index of the winner using the random result and the participant count
            address winner = participants[index]; // Get the address of the winner
            require(!isWinner(winner), "Duplicate winner"); // Check if the winner is not already selected
            winners.push(winner); // Add the winner to the winners array
        }
        calculateRewards(); // Call the function to calculate rewards
    }

    // Function to check if an address is a winner
    function isWinner(address _address) internal view returns (bool) {
        for (uint256 i = 0; i < winners.length; i++) {
            // Loop through the winners array
            if (winners[i] == _address) {
                // Check if the address matches a winner
                return true; // Return true
            }
        }
        return false; // Return false
    }

    // Function to calculate rewards
    function calculateRewards() internal {
        require(winners.length == numberOfWinners, "Winners not selected yet"); // Check if the winners are selected
        for (uint256 i = 0; i < winners.length; i++) {
            // Loop through the winners array
            address winner = winners[i]; // Get the address of the winner
            uint256 reward = prizePool / numberOfWinners; // Calculate the reward for the winner
            rewards[winner] = reward; // Set the reward for the winner
        }
        distributeRewards(); // Call the function to distribute rewards
    }

    // Function to distribute rewards
    function distributeRewards() internal {
        require(winners.length == numberOfWinners, "Winners not selected yet"); // Check if the winners are selected
        for (uint256 i = 0; i < winners.length; i++) {
            // Loop through the winners array
            address winner = winners[i]; // Get the address of the winner
            uint256 reward = rewards[winner]; // Get the reward for the winner
            transfer(winner, reward); // Transfer the reward from the contract to the winner
        }
    }
}
